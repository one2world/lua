.TH "C:/Users/longyg/Documents/gitprojects/lua/src/lmem.h" 3 "2020年 九月 9日 星期三" "Version 1.0" "Lua_Docmention" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/longyg/Documents/gitprojects/lua/src/lmem.h
.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include 'llimits\&.h'\fP
.br
\fC#include 'lua\&.h'\fP
.br

.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fBluaM_error\fP(L)   \fBluaD_throw\fP(L, \fBLUA_ERRMEM\fP)"
.br
.ti -1c
.RI "#define \fBluaM_testsize\fP(n,  e)   	(sizeof(n) >= sizeof(size_t) && \fBcast_sizet\fP((n)) + 1 > \fBMAX_SIZET\fP/(e))"
.br
.ti -1c
.RI "#define \fBluaM_checksize\fP(L,  n,  e)   	(\fBluaM_testsize\fP(n,e) ? \fBluaM_toobig\fP(L) : \fBcast_void\fP(0))"
.br
.ti -1c
.RI "#define \fBluaM_limitN\fP(n,  t)"
.br
.ti -1c
.RI "#define \fBluaM_reallocvchar\fP(L,  b,  on,  n)     \fBcast_charp\fP(\fBluaM_saferealloc_\fP(L, (b), (on)*sizeof(char), (n)*sizeof(char)))"
.br
.ti -1c
.RI "#define \fBluaM_freemem\fP(L,  b,  s)   \fBluaM_free_\fP(L, (b), (s))"
.br
.ti -1c
.RI "#define \fBluaM_free\fP(L,  b)   \fBluaM_free_\fP(L, (b), sizeof(*(b)))"
.br
.ti -1c
.RI "#define \fBluaM_freearray\fP(L,  b,  n)   \fBluaM_free_\fP(L, (b), (n)*sizeof(*(b)))"
.br
.ti -1c
.RI "#define \fBluaM_new\fP(L,  t)   \fBcast\fP(t*, \fBluaM_malloc_\fP(L, sizeof(t), 0))"
.br
.ti -1c
.RI "#define \fBluaM_newvector\fP(L,  n,  t)   \fBcast\fP(t*, \fBluaM_malloc_\fP(L, (n)*sizeof(t), 0))"
.br
.ti -1c
.RI "#define \fBluaM_newvectorchecked\fP(L,  n,  t)     (\fBluaM_checksize\fP(L,n,sizeof(t)), \fBluaM_newvector\fP(L,n,t))"
.br
.ti -1c
.RI "#define \fBluaM_newobject\fP(L,  tag,  s)   \fBluaM_malloc_\fP(L, (s), tag)"
.br
.ti -1c
.RI "#define \fBluaM_growvector\fP(L,  v,  nelems,  size,  t,  limit,  e)"
.br
.ti -1c
.RI "#define \fBluaM_reallocvector\fP(L,  v,  oldn,  n,  t)"
.br
.ti -1c
.RI "#define \fBluaM_shrinkvector\fP(L,  v,  size,  fs,  t)      ((v)=\fBcast\fP(t *, \fBluaM_shrinkvector_\fP(L, v, &(size), fs, sizeof(t))))"
.br
.in -1c
.SS "函数"

.in +1c
.ti -1c
.RI "\fBLUAI_FUNC\fP \fBl_noret\fP \fBluaM_toobig\fP (\fBlua_State\fP *L)"
.br
.ti -1c
.RI "\fBLUAI_FUNC\fP void * \fBluaM_realloc_\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t oldsize, size_t size)"
.br
.ti -1c
.RI "\fBLUAI_FUNC\fP void * \fBluaM_saferealloc_\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t oldsize, size_t size)"
.br
.ti -1c
.RI "\fBLUAI_FUNC\fP void \fBluaM_free_\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t osize)"
.br
.ti -1c
.RI "\fBLUAI_FUNC\fP void * \fBluaM_growaux_\fP (\fBlua_State\fP *L, void *\fBblock\fP, int nelems, int *size, int size_elem, int limit, const char *what)"
.br
.ti -1c
.RI "\fBLUAI_FUNC\fP void * \fBluaM_shrinkvector_\fP (\fBlua_State\fP *L, void *\fBblock\fP, int *nelem, int final_n, int size_elem)"
.br
.ti -1c
.RI "\fBLUAI_FUNC\fP void * \fBluaM_malloc_\fP (\fBlua_State\fP *L, size_t size, int tag)"
.br
.in -1c
.SH "宏定义说明"
.PP 
.SS "#define luaM_checksize(L, n, e)   	(\fBluaM_testsize\fP(n,e) ? \fBluaM_toobig\fP(L) : \fBcast_void\fP(0))"

.PP
在文件 lmem\&.h 第 34 行定义\&.
.SS "#define luaM_error(L)   \fBluaD_throw\fP(L, \fBLUA_ERRMEM\fP)"

.PP
在文件 lmem\&.h 第 17 行定义\&.
.SS "#define luaM_free(L, b)   \fBluaM_free_\fP(L, (b), sizeof(*(b)))"

.PP
在文件 lmem\&.h 第 56 行定义\&.
.SS "#define luaM_freearray(L, b, n)   \fBluaM_free_\fP(L, (b), (n)*sizeof(*(b)))"

.PP
在文件 lmem\&.h 第 57 行定义\&.
.SS "#define luaM_freemem(L, b, s)   \fBluaM_free_\fP(L, (b), (s))"

.PP
在文件 lmem\&.h 第 55 行定义\&.
.SS "#define luaM_growvector(L, v, nelems, size, t, limit, e)"
\fB值:\fP
.PP
.nf
 ((v)=cast(t *, luaM_growaux_(L,v,nelems,&(size),sizeof(t), \
                         luaM_limitN(limit,t),e)))
.fi
.PP
在文件 lmem\&.h 第 66 行定义\&.
.SS "#define luaM_limitN(n, t)"
\fB值:\fP
.PP
.nf
  ((cast_sizet(n) <= MAX_SIZET/sizeof(t)) ? (n) :  \
     cast_uint((MAX_SIZET/sizeof(t))))
.fi
.PP
在文件 lmem\&.h 第 44 行定义\&.
.SS "#define luaM_new(L, t)   \fBcast\fP(t*, \fBluaM_malloc_\fP(L, sizeof(t), 0))"

.PP
在文件 lmem\&.h 第 59 行定义\&.
.SS "#define luaM_newobject(L, tag, s)   \fBluaM_malloc_\fP(L, (s), tag)"

.PP
在文件 lmem\&.h 第 64 行定义\&.
.SS "#define luaM_newvector(L, n, t)   \fBcast\fP(t*, \fBluaM_malloc_\fP(L, (n)*sizeof(t), 0))"

.PP
在文件 lmem\&.h 第 60 行定义\&.
.SS "#define luaM_newvectorchecked(L, n, t)     (\fBluaM_checksize\fP(L,n,sizeof(t)), \fBluaM_newvector\fP(L,n,t))"

.PP
在文件 lmem\&.h 第 61 行定义\&.
.SS "#define luaM_reallocvchar(L, b, on, n)     \fBcast_charp\fP(\fBluaM_saferealloc_\fP(L, (b), (on)*sizeof(char), (n)*sizeof(char)))"

.PP
在文件 lmem\&.h 第 52 行定义\&.
.SS "#define luaM_reallocvector(L, v, oldn, n, t)"
\fB值:\fP
.PP
.nf
   (cast(t *, luaM_realloc_(L, v, cast_sizet(oldn) * sizeof(t), \
                                  cast_sizet(n) * sizeof(t))))
.fi
.PP
在文件 lmem\&.h 第 70 行定义\&.
.SS "#define luaM_shrinkvector(L, v, size, fs, t)      ((v)=\fBcast\fP(t *, \fBluaM_shrinkvector_\fP(L, v, &(size), fs, sizeof(t))))"

.PP
在文件 lmem\&.h 第 74 行定义\&.
.SS "#define luaM_testsize(n, e)   	(sizeof(n) >= sizeof(size_t) && \fBcast_sizet\fP((n)) + 1 > \fBMAX_SIZET\fP/(e))"

.PP
在文件 lmem\&.h 第 31 行定义\&.
.SH "函数说明"
.PP 
.SS "\fBLUAI_FUNC\fP void luaM_free_ (\fBlua_State\fP * L, void * block, size_t osize)"

.PP
在文件 lmem\&.c 第 132 行定义\&.
.SS "\fBLUAI_FUNC\fP void* luaM_growaux_ (\fBlua_State\fP * L, void * block, int nelems, int * size, int size_elem, int limit, const char * what)"

.PP
在文件 lmem\&.c 第 79 行定义\&.
.SS "\fBLUAI_FUNC\fP void* luaM_malloc_ (\fBlua_State\fP * L, size_t size, int tag)"

.PP
在文件 lmem\&.c 第 188 行定义\&.
.SS "\fBLUAI_FUNC\fP void* luaM_realloc_ (\fBlua_State\fP * L, void * block, size_t oldsize, size_t size)"

.PP
在文件 lmem\&.c 第 162 行定义\&.
.SS "\fBLUAI_FUNC\fP void* luaM_saferealloc_ (\fBlua_State\fP * L, void * block, size_t oldsize, size_t size)"

.PP
在文件 lmem\&.c 第 179 行定义\&.
.SS "\fBLUAI_FUNC\fP void* luaM_shrinkvector_ (\fBlua_State\fP * L, void * block, int * nelem, int final_n, int size_elem)"

.PP
在文件 lmem\&.c 第 110 行定义\&.
.SS "\fBLUAI_FUNC\fP \fBl_noret\fP luaM_toobig (\fBlua_State\fP * L)"

.PP
在文件 lmem\&.c 第 124 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 Lua_Docmention 的 源代码自动生成\&.
