.TH "C:/Users/longyg/Documents/gitprojects/lua/src/lfunc.c" 3 "2020年 九月 9日 星期三" "Version 1.0" "Lua_Docmention" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/longyg/Documents/gitprojects/lua/src/lfunc.c
.SH SYNOPSIS
.br
.PP
\fC#include 'lprefix\&.h'\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include 'lua\&.h'\fP
.br
\fC#include 'ldebug\&.h'\fP
.br
\fC#include 'ldo\&.h'\fP
.br
\fC#include 'lfunc\&.h'\fP
.br
\fC#include 'lgc\&.h'\fP
.br
\fC#include 'lmem\&.h'\fP
.br
\fC#include 'lobject\&.h'\fP
.br
\fC#include 'lstate\&.h'\fP
.br

.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fBlfunc_c\fP"
.br
.ti -1c
.RI "#define \fBLUA_CORE\fP"
.br
.in -1c
.SS "函数"

.in +1c
.ti -1c
.RI "\fBCClosure\fP * \fBluaF_newCclosure\fP (\fBlua_State\fP *L, int nupvals)"
.br
.ti -1c
.RI "\fBLClosure\fP * \fBluaF_newLclosure\fP (\fBlua_State\fP *L, int nupvals)"
.br
.ti -1c
.RI "void \fBluaF_initupvals\fP (\fBlua_State\fP *L, \fBLClosure\fP *cl)"
.br
.ti -1c
.RI "static \fBUpVal\fP * \fBnewupval\fP (\fBlua_State\fP *L, int tbc, \fBStkId\fP level, \fBUpVal\fP **prev)"
.br
.ti -1c
.RI "\fBUpVal\fP * \fBluaF_findupval\fP (\fBlua_State\fP *L, \fBStkId\fP level)"
.br
.ti -1c
.RI "static void \fBcallclose\fP (\fBlua_State\fP *L, void *ud)"
.br
.ti -1c
.RI "static int \fBprepclosingmethod\fP (\fBlua_State\fP *L, \fBTValue\fP *obj, \fBTValue\fP *err)"
.br
.ti -1c
.RI "static void \fBvarerror\fP (\fBlua_State\fP *L, \fBStkId\fP level, const char *msg)"
.br
.ti -1c
.RI "static int \fBcallclosemth\fP (\fBlua_State\fP *L, \fBStkId\fP level, int status)"
.br
.ti -1c
.RI "static void \fBtrynewtbcupval\fP (\fBlua_State\fP *L, void *ud)"
.br
.ti -1c
.RI "void \fBluaF_newtbcupval\fP (\fBlua_State\fP *L, \fBStkId\fP level)"
.br
.ti -1c
.RI "void \fBluaF_unlinkupval\fP (\fBUpVal\fP *uv)"
.br
.ti -1c
.RI "int \fBluaF_close\fP (\fBlua_State\fP *L, \fBStkId\fP level, int status)"
.br
.ti -1c
.RI "\fBProto\fP * \fBluaF_newproto\fP (\fBlua_State\fP *L)"
.br
.ti -1c
.RI "void \fBluaF_freeproto\fP (\fBlua_State\fP *L, \fBProto\fP *f)"
.br
.ti -1c
.RI "const char * \fBluaF_getlocalname\fP (const \fBProto\fP *f, int local_number, int pc)"
.br
.in -1c
.SH "宏定义说明"
.PP 
.SS "#define lfunc_c"

.PP
在文件 lfunc\&.c 第 7 行定义\&.
.SS "#define LUA_CORE"

.PP
在文件 lfunc\&.c 第 8 行定义\&.
.SH "函数说明"
.PP 
.SS "static void callclose (\fBlua_State\fP * L, void * ud)\fC [static]\fP"

.PP
在文件 lfunc\&.c 第 103 行定义\&.
.SS "static int callclosemth (\fBlua_State\fP * L, \fBStkId\fP level, int status)\fC [static]\fP"

.PP
在文件 lfunc\&.c 第 150 行定义\&.
.SS "int luaF_close (\fBlua_State\fP * L, \fBStkId\fP level, int status)"

.PP
在文件 lfunc\&.c 第 223 行定义\&.
.SS "\fBUpVal\fP* luaF_findupval (\fBlua_State\fP * L, \fBStkId\fP level)"

.PP
在文件 lfunc\&.c 第 88 行定义\&.
.SS "void luaF_freeproto (\fBlua_State\fP * L, \fBProto\fP * f)"

.PP
在文件 lfunc\&.c 第 272 行定义\&.
.SS "const char* luaF_getlocalname (const \fBProto\fP * f, int local_number, int pc)"

.PP
在文件 lfunc\&.c 第 288 行定义\&.
.SS "void luaF_initupvals (\fBlua_State\fP * L, \fBLClosure\fP * cl)"

.PP
在文件 lfunc\&.c 第 48 行定义\&.
.SS "\fBCClosure\fP* luaF_newCclosure (\fBlua_State\fP * L, int nupvals)"

.PP
在文件 lfunc\&.c 第 27 行定义\&.
.SS "\fBLClosure\fP* luaF_newLclosure (\fBlua_State\fP * L, int nupvals)"

.PP
在文件 lfunc\&.c 第 35 行定义\&.
.SS "\fBProto\fP* luaF_newproto (\fBlua_State\fP * L)"

.PP
在文件 lfunc\&.c 第 245 行定义\&.
.SS "void luaF_newtbcupval (\fBlua_State\fP * L, \fBStkId\fP level)"

.PP
在文件 lfunc\&.c 第 194 行定义\&.
.SS "void luaF_unlinkupval (\fBUpVal\fP * uv)"

.PP
在文件 lfunc\&.c 第 215 行定义\&.
.SS "static \fBUpVal\fP* newupval (\fBlua_State\fP * L, int tbc, \fBStkId\fP level, \fBUpVal\fP ** prev)\fC [static]\fP"

.PP
在文件 lfunc\&.c 第 65 行定义\&.
.SS "static int prepclosingmethod (\fBlua_State\fP * L, \fBTValue\fP * obj, \fBTValue\fP * err)\fC [static]\fP"

.PP
在文件 lfunc\&.c 第 113 行定义\&.
.SS "static void trynewtbcupval (\fBlua_State\fP * L, void * ud)\fC [static]\fP"

.PP
在文件 lfunc\&.c 第 184 行定义\&.
.SS "static void varerror (\fBlua_State\fP * L, \fBStkId\fP level, const char * msg)\fC [static]\fP"

.PP
在文件 lfunc\&.c 第 130 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 Lua_Docmention 的 源代码自动生成\&.
