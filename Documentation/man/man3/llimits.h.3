.TH "D:/gitworkspace/lua/src/llimits.h" 3 "2020年 九月 8日 星期二" "Lua_Docmention" \" -*- nroff -*-
.ad l
.nh
.SH NAME
D:/gitworkspace/lua/src/llimits.h
.SH SYNOPSIS
.br
.PP
\fC#include <limits\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include 'lua\&.h'\fP
.br

.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fBMAX_SIZET\fP   ((size_t)(~(size_t)0))"
.br
.ti -1c
.RI "#define \fBMAX_SIZE\fP"
.br
.ti -1c
.RI "#define \fBMAX_LUMEM\fP   ((\fBlu_mem\fP)(~(\fBlu_mem\fP)0))"
.br
.ti -1c
.RI "#define \fBMAX_LMEM\fP   ((\fBl_mem\fP)(\fBMAX_LUMEM\fP >> 1))"
.br
.ti -1c
.RI "#define \fBMAX_INT\fP   INT_MAX  /* maximum value of an int */"
.br
.ti -1c
.RI "#define \fBlog2maxs\fP(t)   (sizeof(t) * 8 \- 2)"
.br
.ti -1c
.RI "#define \fBispow2\fP(x)   (((x) & ((x) \- 1)) == 0)"
.br
.ti -1c
.RI "#define \fBLL\fP(x)   (sizeof(x)/sizeof(char) \- 1)"
.br
.ti -1c
.RI "#define \fBpoint2uint\fP(p)   ((unsigned int)((size_t)(p) & UINT_MAX))"
.br
.ti -1c
.RI "#define \fBlua_assert\fP(c)   ((void)0)"
.br
.ti -1c
.RI "#define \fBcheck_exp\fP(c,  e)   (e)"
.br
.ti -1c
.RI "#define \fBlua_longassert\fP(c)   ((void)0)"
.br
.ti -1c
.RI "#define \fBluai_apicheck\fP(l,  e)   ((void)l, \fBlua_assert\fP(e))"
.br
.ti -1c
.RI "#define \fBapi_check\fP(l,  e,  msg)   \fBluai_apicheck\fP(l,(e) && msg)"
.br
.ti -1c
.RI "#define \fBUNUSED\fP(x)   ((void)(x))"
.br
.ti -1c
.RI "#define \fBcast\fP(t,  exp)   ((t)(exp))"
.br
.ti -1c
.RI "#define \fBcast_void\fP(i)   \fBcast\fP(void, (i))"
.br
.ti -1c
.RI "#define \fBcast_voidp\fP(i)   \fBcast\fP(void *, (i))"
.br
.ti -1c
.RI "#define \fBcast_num\fP(i)   \fBcast\fP(\fBlua_Number\fP, (i))"
.br
.ti -1c
.RI "#define \fBcast_int\fP(i)   \fBcast\fP(int, (i))"
.br
.ti -1c
.RI "#define \fBcast_uint\fP(i)   \fBcast\fP(unsigned int, (i))"
.br
.ti -1c
.RI "#define \fBcast_byte\fP(i)   \fBcast\fP(\fBlu_byte\fP, (i))"
.br
.ti -1c
.RI "#define \fBcast_uchar\fP(i)   \fBcast\fP(unsigned char, (i))"
.br
.ti -1c
.RI "#define \fBcast_char\fP(i)   \fBcast\fP(char, (i))"
.br
.ti -1c
.RI "#define \fBcast_charp\fP(i)   \fBcast\fP(char *, (i))"
.br
.ti -1c
.RI "#define \fBcast_sizet\fP(i)   \fBcast\fP(size_t, (i))"
.br
.ti -1c
.RI "#define \fBl_castS2U\fP(i)   ((\fBlua_Unsigned\fP)(i))"
.br
.ti -1c
.RI "#define \fBl_castU2S\fP(i)   ((\fBlua_Integer\fP)(i))"
.br
.ti -1c
.RI "#define \fBlikely\fP(x)   (x)"
.br
.ti -1c
.RI "#define \fBunlikely\fP(x)   (x)"
.br
.ti -1c
.RI "#define \fBl_noret\fP   void"
.br
.ti -1c
.RI "#define \fBLUAI_MAXSHORTLEN\fP   40"
.br
.ti -1c
.RI "#define \fBMINSTRTABSIZE\fP   128"
.br
.ti -1c
.RI "#define \fBSTRCACHE_N\fP   53"
.br
.ti -1c
.RI "#define \fBSTRCACHE_M\fP   2"
.br
.ti -1c
.RI "#define \fBLUA_MINBUFFER\fP   32"
.br
.ti -1c
.RI "#define \fBlua_lock\fP(L)   ((void) 0)"
.br
.ti -1c
.RI "#define \fBlua_unlock\fP(L)   ((void) 0)"
.br
.ti -1c
.RI "#define \fBluai_threadyield\fP(L)   {\fBlua_unlock\fP(L); \fBlua_lock\fP(L);}"
.br
.ti -1c
.RI "#define \fBluai_userstateopen\fP(L)   ((void)L)"
.br
.ti -1c
.RI "#define \fBluai_userstateclose\fP(L)   ((void)L)"
.br
.ti -1c
.RI "#define \fBluai_userstatethread\fP(L,  L1)   ((void)L)"
.br
.ti -1c
.RI "#define \fBluai_userstatefree\fP(L,  L1)   ((void)L)"
.br
.ti -1c
.RI "#define \fBluai_userstateresume\fP(L,  n)   ((void)L)"
.br
.ti -1c
.RI "#define \fBluai_userstateyield\fP(L,  n)   ((void)L)"
.br
.ti -1c
.RI "#define \fBluai_numidiv\fP(L,  a,  b)   ((void)L, \fBl_floor\fP(\fBluai_numdiv\fP(L,a,b)))"
.br
.ti -1c
.RI "#define \fBluai_numdiv\fP(L,  a,  b)   ((a)/(b))"
.br
.ti -1c
.RI "#define \fBluai_nummod\fP(L,  a,  b,  m)"
.br
.ti -1c
.RI "#define \fBluai_numpow\fP(L,  a,  b)   ((void)L, \fBl_mathop\fP(pow)(a,b))"
.br
.ti -1c
.RI "#define \fBluai_numadd\fP(L,  a,  b)   ((a)+(b))"
.br
.ti -1c
.RI "#define \fBluai_numsub\fP(L,  a,  b)   ((a)\-(b))"
.br
.ti -1c
.RI "#define \fBluai_nummul\fP(L,  a,  b)   ((a)*(b))"
.br
.ti -1c
.RI "#define \fBluai_numunm\fP(L,  a)   (\-(a))"
.br
.ti -1c
.RI "#define \fBluai_numeq\fP(a,  b)   ((a)==(b))"
.br
.ti -1c
.RI "#define \fBluai_numlt\fP(a,  b)   ((a)<(b))"
.br
.ti -1c
.RI "#define \fBluai_numle\fP(a,  b)   ((a)<=(b))"
.br
.ti -1c
.RI "#define \fBluai_numgt\fP(a,  b)   ((a)>(b))"
.br
.ti -1c
.RI "#define \fBluai_numge\fP(a,  b)   ((a)>=(b))"
.br
.ti -1c
.RI "#define \fBluai_numisnan\fP(a)   (!\fBluai_numeq\fP((a), (a)))"
.br
.ti -1c
.RI "#define \fBcondmovestack\fP(L,  pre,  pos)   ((void)0)"
.br
.ti -1c
.RI "#define \fBcondchangemem\fP(L,  pre,  pos)   ((void)0)"
.br
.in -1c
.SS "类型定义"

.in +1c
.ti -1c
.RI "typedef unsigned long \fBlu_mem\fP"
.br
.ti -1c
.RI "typedef long \fBl_mem\fP"
.br
.ti -1c
.RI "typedef unsigned char \fBlu_byte\fP"
.br
.ti -1c
.RI "typedef signed char \fBls_byte\fP"
.br
.ti -1c
.RI "typedef \fBLUAI_UACNUMBER\fP \fBl_uacNumber\fP"
.br
.ti -1c
.RI "typedef \fBLUAI_UACINT\fP \fBl_uacInt\fP"
.br
.ti -1c
.RI "typedef unsigned long \fBl_uint32\fP"
.br
.ti -1c
.RI "typedef \fBl_uint32\fP \fBInstruction\fP"
.br
.in -1c
.SH "宏定义说明"
.PP 
.SS "#define api_check(l, e, msg)   \fBluai_apicheck\fP(l,(e) && msg)"

.PP
在文件 llimits\&.h 第 105 行定义\&.
.SS "#define cast(t, exp)   ((t)(exp))"

.PP
在文件 llimits\&.h 第 115 行定义\&.
.SS "#define cast_byte(i)   \fBcast\fP(\fBlu_byte\fP, (i))"

.PP
在文件 llimits\&.h 第 122 行定义\&.
.SS "#define cast_char(i)   \fBcast\fP(char, (i))"

.PP
在文件 llimits\&.h 第 124 行定义\&.
.SS "#define cast_charp(i)   \fBcast\fP(char *, (i))"

.PP
在文件 llimits\&.h 第 125 行定义\&.
.SS "#define cast_int(i)   \fBcast\fP(int, (i))"

.PP
在文件 llimits\&.h 第 120 行定义\&.
.SS "#define cast_num(i)   \fBcast\fP(\fBlua_Number\fP, (i))"

.PP
在文件 llimits\&.h 第 119 行定义\&.
.SS "#define cast_sizet(i)   \fBcast\fP(size_t, (i))"

.PP
在文件 llimits\&.h 第 126 行定义\&.
.SS "#define cast_uchar(i)   \fBcast\fP(unsigned char, (i))"

.PP
在文件 llimits\&.h 第 123 行定义\&.
.SS "#define cast_uint(i)   \fBcast\fP(unsigned int, (i))"

.PP
在文件 llimits\&.h 第 121 行定义\&.
.SS "#define cast_void(i)   \fBcast\fP(void, (i))"

.PP
在文件 llimits\&.h 第 117 行定义\&.
.SS "#define cast_voidp(i)   \fBcast\fP(void *, (i))"

.PP
在文件 llimits\&.h 第 118 行定义\&.
.SS "#define check_exp(c, e)   (e)"

.PP
在文件 llimits\&.h 第 94 行定义\&.
.SS "#define condchangemem(L, pre, pos)   ((void)0)"

.PP
在文件 llimits\&.h 第 343 行定义\&.
.SS "#define condmovestack(L, pre, pos)   ((void)0)"

.PP
在文件 llimits\&.h 第 335 行定义\&.
.SS "#define ispow2(x)   (((x) & ((x) \- 1)) == 0)"

.PP
在文件 llimits\&.h 第 66 行定义\&.
.SS "#define l_castS2U(i)   ((\fBlua_Unsigned\fP)(i))"

.PP
在文件 llimits\&.h 第 131 行定义\&.
.SS "#define l_castU2S(i)   ((\fBlua_Integer\fP)(i))"

.PP
在文件 llimits\&.h 第 140 行定义\&.
.SS "#define l_noret   void"

.PP
在文件 llimits\&.h 第 170 行定义\&.
.SS "#define likely(x)   (x)"

.PP
在文件 llimits\&.h 第 153 行定义\&.
.SS "#define LL(x)   (sizeof(x)/sizeof(char) \- 1)"

.PP
在文件 llimits\&.h 第 70 行定义\&.
.SS "#define log2maxs(t)   (sizeof(t) * 8 \- 2)"

.PP
在文件 llimits\&.h 第 60 行定义\&.
.SS "#define lua_assert(c)   ((void)0)"

.PP
在文件 llimits\&.h 第 93 行定义\&.
.SS "#define lua_lock(L)   ((void) 0)"

.PP
在文件 llimits\&.h 第 234 行定义\&.
.SS "#define lua_longassert(c)   ((void)0)"

.PP
在文件 llimits\&.h 第 95 行定义\&.
.SS "#define LUA_MINBUFFER   32"

.PP
在文件 llimits\&.h 第 225 行定义\&.
.SS "#define lua_unlock(L)   ((void) 0)"

.PP
在文件 llimits\&.h 第 235 行定义\&.
.SS "#define luai_apicheck(l, e)   ((void)l, \fBlua_assert\fP(e))"

.PP
在文件 llimits\&.h 第 102 行定义\&.
.SS "#define LUAI_MAXSHORTLEN   40"

.PP
在文件 llimits\&.h 第 197 行定义\&.
.SS "#define luai_numadd(L, a, b)   ((a)+(b))"

.PP
在文件 llimits\&.h 第 315 行定义\&.
.SS "#define luai_numdiv(L, a, b)   ((a)/(b))"

.PP
在文件 llimits\&.h 第 288 行定义\&.
.SS "#define luai_numeq(a, b)   ((a)==(b))"

.PP
在文件 llimits\&.h 第 319 行定义\&.
.SS "#define luai_numge(a, b)   ((a)>=(b))"

.PP
在文件 llimits\&.h 第 323 行定义\&.
.SS "#define luai_numgt(a, b)   ((a)>(b))"

.PP
在文件 llimits\&.h 第 322 行定义\&.
.SS "#define luai_numidiv(L, a, b)   ((void)L, \fBl_floor\fP(\fBluai_numdiv\fP(L,a,b)))"

.PP
在文件 llimits\&.h 第 283 行定义\&.
.SS "#define luai_numisnan(a)   (!\fBluai_numeq\fP((a), (a)))"

.PP
在文件 llimits\&.h 第 324 行定义\&.
.SS "#define luai_numle(a, b)   ((a)<=(b))"

.PP
在文件 llimits\&.h 第 321 行定义\&.
.SS "#define luai_numlt(a, b)   ((a)<(b))"

.PP
在文件 llimits\&.h 第 320 行定义\&.
.SS "#define luai_nummod(L, a, b, m)"
\fB值:\fP
.PP
.nf
  { (void)L; (m) = l_mathop(fmod)(a,b); \
    if (((m) > 0) ? (b) < 0 : ((m) < 0 && (b) > 0)) (m) += (b); }
.fi
.PP
在文件 llimits\&.h 第 303 行定义\&.
.SS "#define luai_nummul(L, a, b)   ((a)*(b))"

.PP
在文件 llimits\&.h 第 317 行定义\&.
.SS "#define luai_numpow(L, a, b)   ((void)L, \fBl_mathop\fP(pow)(a,b))"

.PP
在文件 llimits\&.h 第 310 行定义\&.
.SS "#define luai_numsub(L, a, b)   ((a)\-(b))"

.PP
在文件 llimits\&.h 第 316 行定义\&.
.SS "#define luai_numunm(L, a)   (\-(a))"

.PP
在文件 llimits\&.h 第 318 行定义\&.
.SS "#define luai_threadyield(L)   {\fBlua_unlock\fP(L); \fBlua_lock\fP(L);}"

.PP
在文件 llimits\&.h 第 243 行定义\&.
.SS "#define luai_userstateclose(L)   ((void)L)"

.PP
在文件 llimits\&.h 第 256 行定义\&.
.SS "#define luai_userstatefree(L, L1)   ((void)L)"

.PP
在文件 llimits\&.h 第 264 行定义\&.
.SS "#define luai_userstateopen(L)   ((void)L)"

.PP
在文件 llimits\&.h 第 252 行定义\&.
.SS "#define luai_userstateresume(L, n)   ((void)L)"

.PP
在文件 llimits\&.h 第 268 行定义\&.
.SS "#define luai_userstatethread(L, L1)   ((void)L)"

.PP
在文件 llimits\&.h 第 260 行定义\&.
.SS "#define luai_userstateyield(L, n)   ((void)L)"

.PP
在文件 llimits\&.h 第 272 行定义\&.
.SS "#define MAX_INT   INT_MAX  /* maximum value of an int */"

.PP
在文件 llimits\&.h 第 53 行定义\&.
.SS "#define MAX_LMEM   ((\fBl_mem\fP)(\fBMAX_LUMEM\fP >> 1))"

.PP
在文件 llimits\&.h 第 50 行定义\&.
.SS "#define MAX_LUMEM   ((\fBlu_mem\fP)(~(\fBlu_mem\fP)0))"

.PP
在文件 llimits\&.h 第 48 行定义\&.
.SS "#define MAX_SIZE"
\fB值:\fP
.PP
.nf
                          (sizeof(size_t) < sizeof(lua_Integer) ? MAX_SIZET \
                          : (size_t)(LUA_MAXINTEGER))
.fi
.PP
在文件 llimits\&.h 第 44 行定义\&.
.SS "#define MAX_SIZET   ((size_t)(~(size_t)0))"

.PP
在文件 llimits\&.h 第 41 行定义\&.
.SS "#define MINSTRTABSIZE   128"

.PP
在文件 llimits\&.h 第 208 行定义\&.
.SS "#define point2uint(p)   ((unsigned int)((size_t)(p) & UINT_MAX))"

.PP
在文件 llimits\&.h 第 78 行定义\&.
.SS "#define STRCACHE_M   2"

.PP
在文件 llimits\&.h 第 219 行定义\&.
.SS "#define STRCACHE_N   53"

.PP
在文件 llimits\&.h 第 218 行定义\&.
.SS "#define unlikely(x)   (x)"

.PP
在文件 llimits\&.h 第 154 行定义\&.
.SS "#define UNUSED(x)   ((void)(x))"

.PP
在文件 llimits\&.h 第 110 行定义\&.
.SH "类型定义说明"
.PP 
.SS "typedef \fBl_uint32\fP \fBInstruction\fP"

.PP
在文件 llimits\&.h 第 186 行定义\&.
.SS "typedef long \fBl_mem\fP"

.PP
在文件 llimits\&.h 第 31 行定义\&.
.SS "typedef \fBLUAI_UACINT\fP \fBl_uacInt\fP"

.PP
在文件 llimits\&.h 第 84 行定义\&.
.SS "typedef \fBLUAI_UACNUMBER\fP \fBl_uacNumber\fP"

.PP
在文件 llimits\&.h 第 83 行定义\&.
.SS "typedef unsigned long \fBl_uint32\fP"

.PP
在文件 llimits\&.h 第 183 行定义\&.
.SS "typedef signed char \fBls_byte\fP"

.PP
在文件 llimits\&.h 第 37 行定义\&.
.SS "typedef unsigned char \fBlu_byte\fP"

.PP
在文件 llimits\&.h 第 36 行定义\&.
.SS "typedef unsigned long \fBlu_mem\fP"

.PP
在文件 llimits\&.h 第 30 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 Lua_Docmention 的 源代码自动生成\&.
