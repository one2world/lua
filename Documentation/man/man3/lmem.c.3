.TH "C:/Users/longyg/Documents/gitprojects/lua/src/lmem.c" 3 "2020年 九月 9日 星期三" "Version 1.0" "Lua_Docmention" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/longyg/Documents/gitprojects/lua/src/lmem.c
.SH SYNOPSIS
.br
.PP
\fC#include 'lprefix\&.h'\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include 'lua\&.h'\fP
.br
\fC#include 'ldebug\&.h'\fP
.br
\fC#include 'ldo\&.h'\fP
.br
\fC#include 'lgc\&.h'\fP
.br
\fC#include 'lmem\&.h'\fP
.br
\fC#include 'lobject\&.h'\fP
.br
\fC#include 'lstate\&.h'\fP
.br

.SS "宏定义"

.in +1c
.ti -1c
.RI "#define \fBlmem_c\fP"
.br
.ti -1c
.RI "#define \fBLUA_CORE\fP"
.br
.ti -1c
.RI "#define \fBfirsttry\fP(g,  \fBblock\fP,  os,  ns)   ((*g\->frealloc)(g\->ud, \fBblock\fP, os, ns))"
.br
.ti -1c
.RI "#define \fBMINSIZEARRAY\fP   4"
.br
.in -1c
.SS "函数"

.in +1c
.ti -1c
.RI "void * \fBluaM_growaux_\fP (\fBlua_State\fP *L, void *\fBblock\fP, int nelems, int *psize, int size_elems, int limit, const char *what)"
.br
.ti -1c
.RI "void * \fBluaM_shrinkvector_\fP (\fBlua_State\fP *L, void *\fBblock\fP, int *size, int final_n, int size_elem)"
.br
.ti -1c
.RI "\fBl_noret\fP \fBluaM_toobig\fP (\fBlua_State\fP *L)"
.br
.ti -1c
.RI "void \fBluaM_free_\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t osize)"
.br
.ti -1c
.RI "static void * \fBtryagain\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t osize, size_t nsize)"
.br
.ti -1c
.RI "void * \fBluaM_realloc_\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t osize, size_t nsize)"
.br
.ti -1c
.RI "void * \fBluaM_saferealloc_\fP (\fBlua_State\fP *L, void *\fBblock\fP, size_t osize, size_t nsize)"
.br
.ti -1c
.RI "void * \fBluaM_malloc_\fP (\fBlua_State\fP *L, size_t size, int tag)"
.br
.in -1c
.SH "宏定义说明"
.PP 
.SS "#define firsttry(g, \fBblock\fP, os, ns)   ((*g\->frealloc)(g\->ud, \fBblock\fP, os, ns))"

.PP
在文件 lmem\&.c 第 38 行定义\&.
.SS "#define lmem_c"

.PP
在文件 lmem\&.c 第 7 行定义\&.
.SS "#define LUA_CORE"

.PP
在文件 lmem\&.c 第 8 行定义\&.
.SS "#define MINSIZEARRAY   4"

.PP
在文件 lmem\&.c 第 76 行定义\&.
.SH "函数说明"
.PP 
.SS "void luaM_free_ (\fBlua_State\fP * L, void * block, size_t osize)"

.PP
在文件 lmem\&.c 第 132 行定义\&.
.SS "void* luaM_growaux_ (\fBlua_State\fP * L, void * block, int nelems, int * psize, int size_elems, int limit, const char * what)"

.PP
在文件 lmem\&.c 第 79 行定义\&.
.SS "void* luaM_malloc_ (\fBlua_State\fP * L, size_t size, int tag)"

.PP
在文件 lmem\&.c 第 188 行定义\&.
.SS "void* luaM_realloc_ (\fBlua_State\fP * L, void * block, size_t osize, size_t nsize)"

.PP
在文件 lmem\&.c 第 162 行定义\&.
.SS "void* luaM_saferealloc_ (\fBlua_State\fP * L, void * block, size_t osize, size_t nsize)"

.PP
在文件 lmem\&.c 第 179 行定义\&.
.SS "void* luaM_shrinkvector_ (\fBlua_State\fP * L, void * block, int * size, int final_n, int size_elem)"

.PP
在文件 lmem\&.c 第 110 行定义\&.
.SS "\fBl_noret\fP luaM_toobig (\fBlua_State\fP * L)"

.PP
在文件 lmem\&.c 第 124 行定义\&.
.SS "static void* tryagain (\fBlua_State\fP * L, void * block, size_t osize, size_t nsize)\fC [static]\fP"

.PP
在文件 lmem\&.c 第 146 行定义\&.
.SH "作者"
.PP 
由 Doyxgen 通过分析 Lua_Docmention 的 源代码自动生成\&.
